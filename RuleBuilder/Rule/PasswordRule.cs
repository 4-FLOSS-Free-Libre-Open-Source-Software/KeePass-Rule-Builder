using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Linq;


namespace RuleBuilder.Rule {
	public class PasswordRule : RuleProperty, IPasswordGenerator {
		public PasswordRule() {
			void changeDelegate() {
				this.NotifyRuleChanged();
			}
			this.Components.CollectionChanged += (object _, NotifyCollectionChangedEventArgs args) => {
				changeDelegate();
				if (args.OldItems != null) {
					foreach (object item in args.OldItems) {
						((Component)item).RuleChanged -= changeDelegate;
					}
				}
				if (args.NewItems != null) {
					foreach (object item in args.NewItems) {
						((Component)item).RuleChanged += changeDelegate;
					}
				}
			};
		}

		public PasswordRule(int length, IEnumerable<Component> components, string excludeCharacters) : this() {
			this.Length = length;
			this.SetComponents(components);
			this.ExcludeCharacters = excludeCharacters;
		}

		private PasswordRule(PasswordRule other) : this() {
			this.Length = other.Length;
			this.ExcludeCharacters = other.ExcludeCharacters;
			this.Components = new ObservableCollection<Component>(other.Components.Select((Component component) => component.Clone()));
		}

		private int _length = (int)KeePass.Program.Config.PasswordGenerator.AutoGeneratedPasswordsProfile.Length;
		public int Length {
			get => this._length;
			set {
				if (this._length != value) {
					this._length = value;
					this.NotifyPropertyChanged(nameof(this.Length));
				}
			}
		}

		private string _excludeCharacters = string.Empty;
		public string ExcludeCharacters {
			get => this._excludeCharacters;
			set {
				if (this._excludeCharacters != value) {
					this._excludeCharacters = value;
					this.NotifyPropertyChanged(nameof(this.ExcludeCharacters));
				}
			}
		}

		public ObservableCollection<Component> Components { get; } = new ObservableCollection<Component>();

		public void SetComponents(IEnumerable<Component> newComponents) {
			if (newComponents == null) {
				throw new ArgumentNullException(nameof(newComponents));
			}
			this.Components.Clear();
			foreach (Component component in newComponents) {
				this.Components.Add(component);
			}
		}

		public string NewPassword() {
			List<string> password = new List<string>();
			foreach (Component component in this.Components.Where((Component component) => component.Required)) {
				HashSet<string> chars = CharacterClass.SplitString(component.CharacterClass?.Characters ?? string.Empty);
				foreach (string c in CharacterClass.SplitString(this.ExcludeCharacters)) {
					_ = chars.Remove(c);
				}
				if (chars.Count > 0) {
					password.Add(Random.RandomItem(chars));
				}
			}
			this.FillToLength(password);
			Random.Shuffle(password);
			return string.Join(string.Empty, password);
		}

		private void FillToLength(List<string> password) {
			if (password.Count >= this.Length) {
				return;
			}
			HashSet<string> allCharacters = this.AllCharacters();
			if (allCharacters.Count > 0) {
				while (password.Count < this.Length) {
					password.Add(Random.RandomItem(allCharacters));
				}
			}
			return;
		}

		private HashSet<string> AllCharacters() {
			HashSet<string> chars = new HashSet<string>();
			List<Component> components = this.Components.Where((Component component) => component.CharacterClass != null).ToList();
			foreach (string charSet in
				components.Count > 0
					? components.Select((Component component) => component.CharacterClass?.Characters ?? string.Empty)
					: new List<string>() { CharacterClass.AllCharacters.Characters }
			) {
				chars.UnionWith(CharacterClass.SplitString(charSet));
			}
			foreach (string c in CharacterClass.SplitString(this.ExcludeCharacters)) {
				_ = chars.Remove(c);
			}
			return chars;
		}

		public double EntropyBits() {
			HashSet<string> allCharacters = this.AllCharacters();
			double numTotalPasswords = Math.Pow(allCharacters.Count, this.Length);
			List<CharacterSetCount> requiredSets = this.RequiredCharacterSets();
			if (requiredSets.Count > 5) {
				throw new ArgumentOutOfRangeException("Too many required character sets to calculate the entropy");
			}
			double numInvalidPasswords = 0.0;
			for (int n = 1; n <= requiredSets.Count; n++) {
				foreach (List<CharacterSetCount> required in SubsetsOfLength(requiredSets, n)) {
					numInvalidPasswords += CountPasswordsNotContaining(
						allCharacters,
						this.Length,
						required
					) * (n % 2 == 1 ? 1.0 : -1.0);
				}
			}
			double result = Math.Log(numTotalPasswords - numInvalidPasswords, 2.0);
			if (double.IsInfinity(result) || double.IsNaN(result)) {
				throw new ArgumentOutOfRangeException("Entropy is too large to be calculated");
			}
			return result;
		}

		private List<CharacterSetCount> RequiredCharacterSets() {
			HashSet<string> allCharacters = this.AllCharacters();
			var sets = new List<CharacterSetCount>();
			foreach (Component component in this.Components.Where((Component component) => component.Required)) {
				HashSet<string> chars = CharacterClass.SplitString(component.CharacterClass?.Characters ?? string.Empty);
				chars.IntersectWith(allCharacters);
				AppendOrUpdate(sets, chars);
			}
			return sets;
		}

		private static void AppendOrUpdate(List<CharacterSetCount> list, HashSet<string> chars) {
			foreach (CharacterSetCount count in list) {
				if (count.Characters.SetEquals(chars)) {
					count.Increment();
					return;
				}
			}
			list.Add(new CharacterSetCount(chars));
		}

		private static IEnumerable<List<T>> SubsetsOfLength<T>(List<T> list, int length, int start = 0) {
			if (length == 0) {
				yield return new List<T>();
			} else {
				for (int i = start; i + length - 1 < list.Count; i++) {
					foreach (List<T> set in SubsetsOfLength(list, length - 1, i + 1)) {
						yield return set.Prepend(list[i]).ToList();
					}
				}
			}
		}

		private static double CountPasswordsNotContaining(HashSet<string> allCharacters, int passwordLength, List<CharacterSetCount> charSets) {
			int otherCharCount = allCharacters.Where((string character) => !charSets.Any((CharacterSetCount charSet) => charSet.Characters.Contains(character))).Count();
			if (otherCharCount == 0) {
				return 0.0;
			}
			double total = 0.0;
			foreach (List<CharacterSetCount> shortCount in ShortCounts(charSets)) {
				int remainingLength = passwordLength;
				double passwordCount = 1.0;
				foreach (CharacterSetCount charSet in shortCount) {
					passwordCount *= Combinations(remainingLength, charSet.Count) * Math.Pow(charSet.Characters.Count, charSet.Count);
					remainingLength -= charSet.Count;
				}
				passwordCount *= Math.Pow(otherCharCount, remainingLength);
				total += passwordCount;
			}
			return total;
		}

		private static IEnumerable<List<CharacterSetCount>> ShortCounts(List<CharacterSetCount> charSets, int start = 0) {
			if (start >= charSets.Count) {
				yield return new List<CharacterSetCount>();
			} else {
				for (int n = 0; n < charSets[start].Count; n++) {
					foreach (List<CharacterSetCount> list in ShortCounts(charSets, start + 1)) {
						yield return list.Prepend(charSets[0].WithCount(n)).ToList();
					}
				}
			}
		}

		private static double Combinations(int supersetSize, int subsetSize) {
			double numerator = 1.0;
			for (int n = supersetSize; n > (supersetSize - subsetSize); n--) {
				numerator *= n;
			}
			double denominator = 1.0;
			for (int n = 2; n <= subsetSize; n++) {
				denominator *= n;
			}
			return numerator / denominator;
		}

		public PasswordRule Clone() => new PasswordRule(this);
	}

	class CharacterSetCount {
		public CharacterSetCount(HashSet<string> characters) {
			this.Characters = characters;
		}
		public HashSet<string> Characters { get; }

		public int Count { get; private set; } = 1;

		public CharacterSetCount WithCount(int count) => new CharacterSetCount(this.Characters) {
			Count = count
		};

		public void Increment() {
			this.Count++;
		}
	}
}
